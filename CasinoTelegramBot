import telebot
from telebot import types
import random
import time
import string
import os
from keyboa import Keyboa


token = 'API_Bot_Tocken'  

bot = telebot.TeleBot(token)

ADMIN_USER_ID_Bohdan = 826619403
ADMIN_USER_ID_Anpetro = 728676994
ADMIN_USER_ID_Den = 819889995
ADMIN_USER_IDS = [ADMIN_USER_ID_Bohdan, ADMIN_USER_ID_Anpetro, ADMIN_USER_ID_Den]

if not os.path.exists("balances"):
    os.makedirs("balances")
   

new_users = [] #список для зберігання нового користувача (потірбен для надсилання broadcast повідомлення)
# Функція для читання промокодів з файлу
user_balance_data = {}

random.seed(int(time.time()))

possible_values = [1.5, 1.51, 1.52, 1.53, 1.54, 1.55, 1.6, 1.61, 1.62, 1.63, 1.64, 1.65, 1.7, 1.71, 1.72, 1.73, 1.74, 1.75, 1.76, 1.8, 1.85, 1.9, 1.95, 2.0, 5.0]

# Вибираємо випадкове число з можливих значень




def load_promo_codes():
    promo_codes = {}
    file_path = "promo_codes.txt"

    if os.path.exists(file_path):
        with open(file_path, "r") as file:
            lines = file.readlines()
            for line in lines:
                parts = line.strip().split(',')
                if len(parts) == 2:
                    promo_code, amount = parts
                    promo_codes[promo_code] = int(amount)
    return promo_codes

def load_balance(user_id):
    file_path = f"balances/{user_id}.txt"
    if os.path.exists(file_path):
        with open(file_path, "r") as file:
            return float(file.read())  # Зчитувати як float, а не int
    else:
        return 0.0  # За замовчуванням баланс 0.0 для нових користувачів

def save_balance(user_id, balance):
    file_path = f"balances/{user_id}.txt"
    with open(file_path, "w") as file:
        file.write(str(balance))

# Функція для збереження промокодів в файл
def save_promo_codes(promo_codes):
    file_path = "promo_codes.txt"
    with open(file_path, "w") as file:
        for promo_code, amount in promo_codes.items():
            file.write(f"{promo_code},{amount}\n")
#клас, який відображає таблицю бази даних для промокодів

#клас який відображає таблицю бази даних про користувача
playing_mines = {}

class Game:
    def __init__(self, user_id, bet):
        self.user_id = user_id
        self.bet = bet
        self.game_board = [[' ' for _ in range(3)] for _ in range(3)]
        self.mines = []
        self.diamonds = []
        self.clicked_cells = set()
        self.game_over = False
        self.current_win = 0
        self.discovered_diamonds = set()  # Зберігає алмази, які вже були виявлені

    def generate_mines_and_diamonds(self):
        self.mines = random.sample(range(9), 2)
        self.diamonds = [i for i in range(9) if i not in self.mines]

    def create_game_markup(self):
        markup = types.InlineKeyboardMarkup(row_width=3)
        for i in range(3):
            row_buttons = []
            for j in range(3):
                button_text = self.game_board[i][j]
                row_buttons.append(types.InlineKeyboardButton(button_text, callback_data=f'{i}_{j}'))
            markup.add(*row_buttons)
        markup.add(types.InlineKeyboardButton("Забрати!", callback_data="claim"))
        return markup
    
@bot.message_handler(commands=['admin'])
def admin_panel(message):
    user_id = message.from_user.id

    # Перевірка чи користувач має права адміністратора
    if user_id in ADMIN_USER_IDS:
        # Створення клавіатури для адмін-панелі
        admin_markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        item_balance = types.KeyboardButton("Видати баланс")
        item_back = types.KeyboardButton("Назад")
        item_feedback = types.KeyboardButton("Відповісти користувачеві")
        item_ads = types.KeyboardButton("Реклама")
        item_users = types.KeyboardButton("Користувачі")
        admin_markup.row(item_balance, item_back,item_feedback,item_ads, item_users)

        # Відправлення повідомлення з клавіатурою
        bot.send_message(message.chat.id, "Виберіть дію ↓", reply_markup=admin_markup)
    else:
        bot.send_message(message.chat.id, "Ви не маєте прав для доступу до адміністративної панелі.")

@bot.message_handler(func=lambda message: message.text == "Користувачі")
def uesrs(message):
    user_id = message.from_user.id

    users_markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    all_users = types.KeyboardButton("Корисутвачі в мережі")
    block_users = types.KeyboardButton("Заблокувати користувача")
    unblock_user = types.KeyboardButton("Розблокувати користувача")
    step_back = types.KeyboardButton("Нaзад")
    users_markup.add(all_users, block_users,unblock_user, step_back)
    # Відправлення повідомлення з клавіатурою "Назад" і видаленням усіх інших кнопок
    bot.send_message(user_id, "Виберіть дію ↓", reply_markup=users_markup)

@bot.message_handler(func=lambda message: message.text == "Корисутвачі в мережі")
def users_online(message):
    admin_id = message.from_user.id
    counter_users = 0
    for users_id in new_users:
        balance = load_balance(users_id)
        if users_id in ADMIN_USER_IDS:
            bot.send_message(admin_id, f"Користувач: {users_id}, баланс: {balance} - Адміністратор")
        else:
            bot.send_message(admin_id, f"Користувач: {users_id}, баланс: {balance}")
        counter_users += 1
    bot.send_message(admin_id, f"Користувачів в мережі: {counter_users}")

@bot.message_handler(func=lambda message: message.text == "Заблокувати користувача")
def block_uesr_info(message):
    admin_id = message.from_user.id
    bot.send_message(admin_id, "Введіть ідентифікатор користувача і причину бану: ")
    bot.register_next_step_handler(message, block_user)

blocked_user = "blocked_users.txt" # файл з заблокованими корисутвачами
def block_user(message):
    try:
        # Отримання введеного ідентифікатора користувача і причини бану
        user_id, reason = message.text.split(" ", 1)
   
        with open(blocked_user, "a") as file:
            file.write(f"User ID: {user_id}, Reason: {reason}\n")

        # Відправлення повідомлення про успішне блокування
        bot.send_message(message.chat.id, f"Користувача з ID {user_id} заблоковано з причиною: {reason}")
        bot.send_message(user_id, f"Вас заблоковано з причиною: {reason}")
    except ValueError:
        bot.send_message(message.chat.id, "Неправильний формат введення. Введіть ідентифікатор користувача і причину через пробіл.")


@bot.message_handler(func=lambda message: message.text == "Розблокувати користувача")
def unblock_user_info(message):
    admin_id = message.from_user.id
    bot.send_message(admin_id, "Введіть ідентифікатор користувача, якого ви хочете розблокувати: ")
    bot.register_next_step_handler(message, unblock_user)


@bot.message_handler(func=lambda message: message.text == "Нaзад")
def go_back_admin(message):
    user_id = message.from_user.id

    # Створення клавіатури для видалення усіх інших кнопок і додавання кнопки "Особистий кабінет"
    back_markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    item_balance = types.KeyboardButton("Видати баланс")
    item_back = types.KeyboardButton("Назад")
    item_feedback = types.KeyboardButton("Відповісти користувачеві")
    item_ads = types.KeyboardButton("Реклама")
    item_users = types.KeyboardButton("Користувачі")
    back_markup.row(item_balance, item_back,item_feedback,item_ads, item_users)

    # Відправлення повідомлення з клавіатурою "Назад" і видаленням усіх інших кнопок
    bot.send_message(user_id, "Ви повернулися назад.", reply_markup=back_markup)





def unblock_user(message):
    try:
        # Отримання введеного ідентифікатора користувача
        user_id = message.text

        # Відкриваємо файл блокувань і читаємо його рядок за рядком
        with open("blocked_users.txt", "r") as file:
            lines = file.readlines()

        # Створюємо новий файл без інформації про розблокованого користувача
        with open("blocked_users.txt", "w") as file:
            for line in lines:
                if not line.startswith(f"User ID: {user_id}"):
                    file.write(line)

        # Відправлення повідомлення про успішне розблокування
        bot.send_message(message.chat.id, f"Користувача з ID {user_id} розблоковано.")
        bot.send_message(user_id, "Вас розблоковано в боті.")
    except ValueError:
        bot.send_message(message.chat.id, "Неправильний формат введення. Введіть ідентифікатор користувача, якого ви хочете розблокувати.")

# Функція для масової розсилки повідомлень усім користувачам
def send_broadcast_message(message_text):
    for user_id in new_users:
        bot.send_message(user_id, message_text)

# Обробник кнопки "Реклама"
@bot.message_handler(func=lambda message: message.text == "Реклама")
def advertisement(message):
    user_id = message.chat.id
    if user_id in ADMIN_USER_IDS:
        bot.send_message(user_id, "Введіть рекламу, яку ви хочете надіслати:")
        bot.register_next_step_handler(message, send_advertisement)

def send_advertisement(message):
    user_id = message.chat.id
    advertisement_text = message.text
    send_broadcast_message(advertisement_text)
    bot.send_message(user_id, "Реклама успішно надіслана")


# Обробник для кнопки "Відповісти користувачеві"
@bot.message_handler(func=lambda message: message.text == "Відповісти користувачеві")
def reply_to_user_button(message):
    user_id = message.from_user.id
    # Відправляємо повідомлення для запиту інформації від адміністратора
    bot.send_message(ADMIN_USER_ID_Bohdan, "Введіть ідентифікатор користувача та повідомлення, яке ви хочете надіслати. Наприклад, '12345 Ваше повідомлення'")
    bot.register_next_step_handler(message, forward_message_to_user)

# Функція для пересилання повідомлення користувачеві
def forward_message_to_user(message):
    admin_id = message.chat.id
    input_text = message.text.strip()
    parts = input_text.split(' ', 1)  # Розділяємо введений текст на ідентифікатор користувача та повідомлення
    if len(parts) == 2:
        user_id, reply_text = parts
        bot.send_message(int(user_id), f'Повідомлення від адміністратора:\n\n{reply_text}')
        bot.send_message(admin_id, f'Повідомлення надіслано користувачу {user_id}')
    else:
        bot.send_message(admin_id, "Неправильний формат введення. Введіть ідентифікатор користувача та повідомлення через пробіл.")

@bot.message_handler(func=lambda message: message.text == "Видати баланс")
def issue_balance(message):
    user_id = message.from_user.id
    # Відправлення повідомлення з інструкціями щодо введення команди
    instructions = "Для поповнення балансу користувача введіть:\n/give_balance user_id +-=сумма"
    bot.send_message(user_id, instructions)
# ...

@bot.message_handler(func=lambda message: message.text == "Назад")
def go_back(message):
    user_id = message.from_user.id

    # Створення клавіатури для видалення усіх інших кнопок і додавання кнопки "Особистий кабінет"
    back_markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    item_profile = types.KeyboardButton("Особистий кабінет")
    item_promo_code = types.KeyboardButton("Промокод")
    item_available_games = types.KeyboardButton("Ігри")
    back_markup.add(item_profile, item_promo_code, item_available_games)
    # Відправлення повідомлення з клавіатурою "Назад" і видаленням усіх інших кнопок
    bot.send_message(user_id, "Ви повернулися назад.", reply_markup=back_markup)




@bot.message_handler(commands=['give_balance'])
def give_balance(message):
    user_id = message.from_user.id

    # Перевірка чи користувач має права адміністратора
    if user_id in ADMIN_USER_IDS:
        # Розділення тексту команди на аргументи
        args = message.text.split()
    
        if len(args) != 3 or (args[2][0] not in ['+', '-', '=']):
            bot.send_message(user_id, "Неправильний формат команди. Використовуйте: /give_balance user_id +сумма (або -сумма, =сумма)")
        else:
            try:
                target_user_id = int(args[1])
                operation = args[2][0]  # Отримуємо знак +, - або =
                amount = int(args[2][1:])  # Отримуємо суму без знаку

                if operation == '+':
                    # Додавання суми до балансу користувача
                    current_balance = load_balance(target_user_id)
                    save_balance(target_user_id, current_balance + amount)
                    bot.send_message(user_id, f"Баланс користувача {target_user_id} збільшено на {amount}.")
                elif operation == '-':
                    # Віднімання суми від балансу користувача
                    current_balance = load_balance(target_user_id)
                    if current_balance >= amount:
                        save_balance(target_user_id, current_balance - amount)
                        bot.send_message(user_id, f"Баланс користувача {target_user_id} зменшено на {amount}.")
                    else:
                        bot.send_message(user_id, f"У користувача недостатньо коштів для зменшення балансу на {amount}.")
                elif operation == '=':
                    # Встановлення точного балансу користувача
                    save_balance(target_user_id, amount)
                    bot.send_message(user_id, f"Баланс користувача {target_user_id} встановлено на {amount}.")
            except ValueError:
                bot.send_message(user_id, "Неправильний формат команди. Використовуйте: /give_balance user_id +сумма (або -сумма, =сумма)")
    else:
        bot.send_message(message.chat.id, "Ви не маєте прав для виконання цієї команди.")



# ...

promo_codes = load_promo_codes()  # Завантаження промокодів з файлу при запуску бота

@bot.message_handler(commands=['create_promo_code'])
def create_promo_code(message):
    user_id = message.from_user.id

    # Перевірка чи користувач має права адміністратора
    if user_id in ADMIN_USER_IDS:
        args = message.text.split()

        if len(args) != 2:
            bot.send_message(user_id, "Неправильний формат команди. Використовуйте: /create_promo_code сумма")
        else:
            try:
                amount = int(args[1])
                if amount <= 0:
                    bot.send_message(user_id, "Сума промокоду повинна бути більше нуля.")
                else:
                    promo_code = generate_promo_code()
                    promo_codes[promo_code] = amount
                    save_promo_codes(promo_codes)  # Збереження промокодів у файл

                    bot.send_message(user_id, f"Створено новий промокод: {promo_code} на суму {amount}.")
            except ValueError:
                bot.send_message(user_id, "Неправильний формат команди. Використовуйте: /create_promo_code сумма")
    else:
        bot.send_message(message.chat.id, "Ви не маєте прав для виконання цієї команди.")



@bot.message_handler(commands=['check_promo_code'])
def check_promo_code(message):
    user_id = message.from_user.id
    args = message.text.split()

    # Перевірка чи користувач має права адміністратора
    if user_id in ADMIN_USER_IDS:
        if len(args) != 2:
            bot.send_message(user_id, "Неправильний формат команди. Використовуйте: /check_promo_code promo_code")
        else:
            promo_code = args[1]

            if promo_code in promo_codes:
                amount = promo_codes[promo_code]
                bot.send_message(user_id, f"Промокод {promo_code} відповідає сумі {amount}.")
            else:
                bot.send_message(user_id, f"Промокод {promo_code} не знайдено.")
    else:
        bot.send_message(message.chat.id, "Ви не маєте прав для виконання цієї команди.")


def generate_promo_code(length=6):
    characters = string.ascii_letters + string.digits
    return ''.join(random.choice(characters) for _ in range(length))

# Зберігання даних про гри кожного гравця

@bot.message_handler(commands=['bomb'])
def bomb(message):
    user_id = message.from_user.id

    if user_id in playing_mines:
        bot.send_message(message.chat.id, "Ви вже граєте в гру з мінами.")
        return
    
    try:
        bet = int(message.text.split(' ')[1])
        if bet > 1:
            balance = load_balance(user_id)  # Замість цього використовуйте вашу функцію для завантаження балансу
            if balance >= bet:
                balance -= bet
                # Зберігання балансу користувача
                save_balance(user_id, balance)
                
                # Створення нової гри для користувача
                game = Game(user_id, bet)
                game.generate_mines_and_diamonds()
                playing_mines[user_id] = {"game_started": True, "game": game}
                
                markup = game.create_game_markup()
                bot.send_message(message.chat.id, f"Гра почалася! Ваша поточна ставка: {bet}. Спробуйте відкрити алмази, уникайте мін.", reply_markup=markup)
            else:
                bot.send_message(message.chat.id, "У вас недостатньо коштів для цієї ставки.")
        else:
            bot.send_message(message.chat.id, "Ставка повинна бути більше 1 і цілим числом.")
    except (IndexError, ValueError):
        bot.send_message(message.chat.id, "Введіть команду у форматі /bomb сумма (де сумма - це ваша ставка).")

# Оновлений обробник натискання на клавішу поля гри
@bot.callback_query_handler(func=lambda call: playing_mines.get(call.from_user.id) is not None)
def update_board(call):
    user_id = call.from_user.id
    game_data = playing_mines.get(user_id)

    if not game_data:
        return
    
    if game_data["game"].game_over:
        return

    if call.data == "claim":
        if not game_data["game"].game_over:
            balance = load_balance(user_id)  
            balance += game_data["game"].current_win
            # Зберігання нового балансу користувача
            save_balance(user_id, balance)
            
            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id,
                                  text=f"Ви забрали {game_data['game'].current_win} грн. Гра завершена.")
            game_data["game"].game_over = True

            playing_mines.pop(user_id, None)
    else:
        row, col = map(int, call.data.split('_'))
        cell_id = row * 3 + col

        if cell_id in game_data["game"].clicked_cells:
            return  # Ігнорувати клітини, які вже були натиснуті

        game = game_data["game"]

        if cell_id in game.mines:
            game.game_board[row][col] = '💣'
            markup = game.create_game_markup()
            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id,
                                  text="Гра завершилася. Ви програли! 💣", reply_markup=markup)
            game.game_over = True

            playing_mines.pop(user_id, None)
        elif cell_id in game.diamonds:
            if cell_id not in game.discovered_diamonds:  # Перевірити, чи алмаз вже був виявлений
                game.game_board[row][col] = '💎'
                markup = game.create_game_markup()
                game.current_win += 0.5 * game.bet
                bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id,
                                      text=f"Алмаз виявлено! Ваш виграш: {game.current_win} грн. Ваша поточна ставка: {game.bet}.", reply_markup=markup)
                game.discovered_diamonds.add(cell_id)  # Додати алмаз до списку виявлених
            

def is_user_blocked(user_id): #перевірка чи користувач заблокований
    with open(blocked_user, "r") as file:
        lines = file.readlines()
        for line in lines:
            if f"User ID: {user_id}" in line:
                return True
    return False



class Player:
    def __init__(self, user_id):
        self.user_id = user_id
        self.hand = []
        self.is_playing = False
        self.bet = 0
        self.current_win = 0

class BlackjackGame:
    def __init__(self):
        self.games = {}  # Зберігайте гри для різних гравців
        self.deck = self.get_deck()
        self.dealer_hand = []

    def get_deck(self):
        suits = ['Черви', 'Бубни', 'Хрести', 'Піки']
        ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'Валет', 'Дама', 'Король', 'Туз']
        return [{'rank': rank, 'suit': suit} for rank in ranks for suit in suits]

    def create_game(self, user_id):
        if user_id not in self.games:
            self.games[user_id] = {
                "players": {},
                "dealer_hand": [],
                "current_player": None
            }

    def get_game(self, user_id):
        return self.games.get(user_id)

    def deal_initial_cards(self, game):
        for player in game["players"].values():
            if not player.is_playing:
                continue
            player.hand = [random.choice(self.deck), random.choice(self.deck)]
        game["dealer_hand"] = [random.choice(self.deck), random.choice(self.deck)]

    def calculate_hand_value(self, hand):
        values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'Валет': 10, 'Дама': 10, 'Король': 10, 'Туз': 11}
        total_value = sum([values[card['rank']] for card in hand])
        aces = [card for card in hand if card['rank'] == 'Туз']
        while total_value > 21 and aces:
            total_value -= 10
            aces.pop()
        return total_value

game = BlackjackGame()

@bot.message_handler(commands=['blackjack'])
def start_game(message):
    user_id = message.from_user.id
    game.create_game(user_id)
    game_instance = game.get_game(user_id)

    if user_id not in game_instance["players"]:
        game_instance["players"][user_id] = Player(user_id)
    
    player = game_instance["players"][user_id]

    try:
        player.bet = int(message.text.split(' ')[1])
        if player.bet > 1:
            balance = load_balance(user_id)
            if balance >= player.bet:
                balance -= player.bet
                save_balance(user_id, balance)

                player.is_playing = True
                player.hand = []
                game.deal_initial_cards(game_instance)
                game_instance["current_player"] = player

                bot.send_message(message.chat.id, "Гра в блекджек почалася! Твої карти:")
                bot.send_message(message.chat.id, get_hand_string(player.hand))
                bot.send_message(message.chat.id, f"Загальна сума: {game.calculate_hand_value(player.hand)}")
                bot.send_message(message.chat.id, "Карта дилера:")
                bot.send_message(message.chat.id, get_hand_string([game_instance["dealer_hand"][0]]))
                bot.send_message(message.chat.id, "Вибери, що робити: /hit - взяти ще карту, /stand - закінчити хід")
            else:
                bot.send_message(message.chat.id, "У вас недостатньо коштів для цієї ставки")
        else:
            bot.send_message(message.chat.id, "Ставка повинна бути більше 1 і цілим числом.")
    except (IndexError, ValueError):
        bot.send_message(message.chat.id, "Введіть команду у форматі /blackjack сумма (де сумма - це ваша ставка).")

@bot.message_handler(commands=['hit'])
def hit(message):
    user_id = message.from_user.id

    balance = load_balance(user_id)

    game_instance = game.get_game(user_id)
    if not game_instance:
        bot.send_message(message.chat.id, "Почніть гру командою /blackjack")
        return

    player = game_instance["players"].get(user_id)

    if not player or not player.is_playing:
        bot.send_message(message.chat.id, "Почніть гру командою /blackjack")
        return

    card = random.choice(game.deck)
    player.hand.append(card)
    bot.send_message(message.chat.id, f"Ти взяв(ла) карту {card['rank']} {card['suit']}")
    bot.send_message(message.chat.id, get_hand_string(player.hand))
    total_value = game.calculate_hand_value(player.hand)
    bot.send_message(message.chat.id, f"Загальна сума: {total_value}")
    if total_value > 21:
        bot.send_message(message.chat.id, "Ти перебрав(ла)!")
        bot.send_message(message.chat.id, f"Ваш поточний баланс: {balance}")
        end_game(message)
    else:
        bot.send_message(message.chat.id, "Вибери, що робити: /hit - взяти ще карту, /stand - закінчити хід")

@bot.message_handler(commands=['stand'])
def stand(message):
    user_id = message.from_user.id

    game_instance = game.get_game(user_id)
    if not game_instance:
        bot.send_message(message.chat.id, "Почніть гру командою /blackjack")
        return

    player = game_instance["players"].get(user_id)

    if not player or not player.is_playing:
        bot.send_message(message.chat.id, "Почніть гру командою /blackjack")
        return

    game_instance["current_player"] = None
    dealer_total = game.calculate_hand_value(game_instance["dealer_hand"])
    while dealer_total < 17:
        card = random.choice(game.deck)
        game_instance["dealer_hand"].append(card)
        dealer_total = game.calculate_hand_value(game_instance["dealer_hand"])
    bot.send_message(message.chat.id, "Карти дилера:")
    bot.send_message(message.chat.id, get_hand_string(game_instance["dealer_hand"]))
    bot.send_message(message.chat.id, f"Загальна сума дилера: {dealer_total}")

    for player in game_instance["players"].values():
        if player.is_playing:
            player_total = game.calculate_hand_value(player.hand)

            random_number = random.choice(possible_values)

            if dealer_total > 21 or (player_total <= 21 and player_total > dealer_total):
                player.current_win += random_number * player.bet
                bot.send_message(message.chat.id, f"Гравець {player.user_id} переміг! Бонус: {random_number}")
                balance = load_balance(player.user_id)
                balance += player.current_win
                save_balance(player.user_id, balance)
                bot.send_message(message.chat.id, f"Ваш поточний баланс: {balance}")

            elif player_total == dealer_total:
                bot.send_message(message.chat.id, f"Гравець {player.user_id} нічия!")
                player.current_win = player.bet
                balance = load_balance(player.user_id)
                balance += player.current_win
                save_balance(player.user_id, balance)
                bot.send_message(message.chat.id, f"Ваш поточний баланс: {balance}")
            else:
                bot.send_message(message.chat.id, f"Гравець {player.user_id} програв.")
                balance = load_balance(player.user_id)
                bot.send_message(message.chat.id, f"Ваш поточний баланс: {balance}")

    
    # Очистити руку та обнулити current_win для кожного гравця
    for player in game_instance["players"].values():
        player.hand = []
        player.current_win = 0

    end_game(message)

def end_game(message):
    global player_hand, dealer_hand
    game.players = {}
    game.deck = game.get_deck()
    game.dealer_hand = []
    game.current_player = None
    bot.send_message(message.chat.id, "Щоб почати нову гру, введи /blackjack")

def get_hand_string(hand):
    return '\n'.join([f"{card['rank']} {card['suit']}" for card in hand])


# Ідентифікатор користувача, який має права адміністратора

@bot.message_handler(commands=['start'])
def start(message):

    user_id = message.from_user.id
    is_blocked = is_user_blocked(user_id)
    if is_blocked == True:
        bot.send_message(user_id, "Ви заблоковані за порушення правил і не можете користуватися ботом") 
    else:
        if user_id not in new_users:
            new_users.append(user_id)
        balance = load_balance(user_id)
        if balance == 0:
            balance = 5  # Початковий баланс 100 для нових користувачів
            save_balance(user_id, balance)

        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        item_profile = types.KeyboardButton("Особистий кабінет")
        item_promo_code = types.KeyboardButton("Промокод")
        item_available_games = types.KeyboardButton("Ігри")
        tech_support = types.KeyboardButton("Зворотній зв'язок")
        add_balance = types.KeyboardButton("Поповнити баланс")
        markup.add(item_profile, item_promo_code, item_available_games, tech_support, add_balance)

        # Відправляємо користувачу привітальне повідомлення разом із кнопками
        bot.send_message(user_id, "Вітаю! Виберіть одну з опцій нижче:", reply_markup=markup)

  
        bot.send_message(message.chat.id, f"Давайте грати у гру!\n\nВаш баланс: {balance}", reply_markup=markup)

        @bot.message_handler(commands=['start'])
        def start(message):
            bot.send_message(message.chat.id, 'Вітаю! Це ваш бот.')

        @bot.message_handler(func=lambda message: message.text == "Ігри")
        def show_games(message):
            user_id = message.from_user.id
            balance = load_balance(user_id)
            # Використовуйте режим "HTML" для форматування
            games_list_html = f"<b>Ваш баланс:</b> {balance} UAH\n\n"
            games_list_html += "<b>Доступні ігри:</b>\n"
            games_list_html += "Кубик - /dice <i>сума</i>\n"
            games_list_html += "Баскетбол - /basket <i>сума</i>\n"
            games_list_html += "Дартс - /darts <i>сума</i>\n"
            games_list_html += "Бомби - /bomb <i>сума</i>\n"
            games_list_html += "БлекДжек - /blackjack <i>сума</i>\n"
            
            
            # Використовуйте режим "MarkdownV2" для форматування
            games_list_markdown = "*Ваш баланс:* " + str(balance) + " UAH\n\n"
            games_list_markdown += "*Доступні ігри:*\n"
            games_list_markdown += "Кубик - /dice _сума_\n"
            games_list_markdown += "Баскетбол - /basket _сума_\n"
            games_list_markdown += "Дартс - /Дартс _сума_\n" 
            games_list_markdown += "Бомби - /bomb _сума_\n"
            games_list_markdown += "БлекДжек - /blackjack _сума_\n"
            
            # Відправлення повідомлення з обидвоми варіантами форматування
            bot.send_message(message.chat.id, games_list_html, parse_mode="HTML")
            bot.send_message(message.chat.id, games_list_markdown, parse_mode="MarkdownV2")
            



        @bot.message_handler(commands=['dice'])
        def dice_command(message):
            try:
                user_id = message.from_user.id
                balance = load_balance(user_id)
                bet = int(message.text.split(' ')[1])
                if bet <= balance:
                    balance -= bet
                    save_balance(user_id, balance)
                    dice_message_1 = bot.send_dice(message.chat.id)
                    dice_message_2 = bot.send_dice(message.chat.id)

                    dice_value_1 = dice_message_1.dice.value
                    dice_value_2 = dice_message_2.dice.value

                    time.sleep(3.5)

                    result_message = f"Перший кубик показав число: {dice_value_1}.\n" \
                                    f"Другий кубик показав число: {dice_value_2}.\n"
                    
                    random_number = random.choice(possible_values)

                    if dice_value_2 > dice_value_1:
                        result_message += f"Ви виграли {bet * random_number}! Бонус: {random_number}"  
                        balance += bet * random_number
                    elif dice_value_2 < dice_value_1:
                        result_message += "Ви програли."
                    else:
                        result_message += "Нічия!"
                        balance += bet

                    save_balance(user_id, balance)
                    bot.send_message(message.chat.id, result_message)
                else:
                    bot.send_message(message.chat.id, "У вас недостатньо коштів для гри.")
            except IndexError:
                bot.send_message(message.chat.id, "Введіть команду у форматі /dice сума")




        @bot.message_handler(commands=['basket'])
        def basket_command(message):
            try:
                user_id = message.from_user.id
                balance = load_balance(user_id)
                bet = int(message.text.split(' ')[1])
                if bet <= balance:
                    balance -= bet
                    save_balance(user_id, balance)

                    dice_message = bot.send_dice(message.chat.id, emoji="🏀")
                    dice_value = dice_message.dice.value
                    time.sleep(4)

                    random_number = random.choice(possible_values)


                    if dice_value >= 4:
                        bot.send_message(message.chat.id, f"Ви виграли {bet * random_number}! М'яч попав в кільце. Бонус: {random_number}", reply_to_message_id=message.message_id)
                        balance += int(bet * random_number)
                    else: 
                        bot.send_message(message.chat.id, f"Ви програли. М'яч не попав.", reply_to_message_id=message.message_id)

                    save_balance(user_id, balance)
                else:
                    bot.send_message(message.chat.id, "У вас недостатньо коштів для гри.")
            except (IndexError, ValueError):
                bot.send_message(message.chat.id, "Введіть команду у форматі /basket сума")

                

        @bot.message_handler(commands=['darts'])
        def basket_command(message):
            try:
                user_id = message.from_user.id
                balance = load_balance(user_id)
                bet = int(message.text.split(' ')[1])
                if bet <= balance:
                    balance -= bet
                    save_balance(user_id, balance)

                    dice_message = bot.send_dice(message.chat.id, emoji="🎯")
                    dice_value = dice_message.dice.value
                    time.sleep(6)

                    random_number = random.choice(possible_values)


                    if dice_value >= 6:
                        bot.send_message(message.chat.id, f"Ви виграли {bet * random_number}! Дротик потрапив у яблучко. Бонус: {random_number}", reply_to_message_id=message.message_id)
                        balance += int(bet * random_number)
                    else: 
                        bot.send_message(message.chat.id, f"Ви програли. Дротик не попав.", reply_to_message_id=message.message_id)

                    save_balance(user_id, balance)
                else:
                    bot.send_message(message.chat.id, "У вас недостатньо коштів для гри.")
            except (IndexError, ValueError):
                bot.send_message(message.chat.id, "Введіть команду у форматі /darts сума")




        @bot.message_handler(func=lambda message: message.text == "Особистий кабінет")
        def profile(message):
            user_id = message.from_user.id
            balance = load_balance(user_id)

            # Отримання інформації про користувача
            user_info = bot.get_user_profile_photos(user_id).photos
            user_avatar = None
            if user_info:
                user_avatar = user_info[0][-1].file_id

            user_id_message = f"Ідентифікатор користувача: {user_id}"
            user_balance_message = f"Ваш баланс: {balance}"

            # Відправлення інформації про користувача з аватаркою
            if user_avatar:
                bot.send_photo(message.chat.id, user_avatar, caption=user_id_message + "\n" + user_balance_message)
            else:
                bot.send_message(message.chat.id, user_id_message + "\n" + user_balance_message)



        @bot.message_handler(func=lambda message: message.text == "Промокод")
        def enter_promo_code(message):
            user_id = message.from_user.id
            
            bot.send_message(user_id, "Введіть промокод:")
            bot.register_next_step_handler(message, process_promo_code)
           
        def process_promo_code(message):
            user_id = message.from_user.id
            promo_code = message.text

            if promo_code in promo_codes:
                amount = promo_codes[promo_code]
                current_balance = load_balance(user_id)
                save_balance(user_id, current_balance + amount)
                bot.send_message(user_id, f"Ваш баланс збільшено на {amount}.")
            else:
                bot.send_message(user_id, "Недійсний промокод. Спробуйте ще раз або зверніться до адміністратора.")

        user_context = {}


        # Функція для обробки кнопки "Написати адміну"
        @bot.message_handler(func=lambda message: message.text == "Зворотній зв'язок")
        def send_message_to_admin(message):
            user_id = message.chat.id
            user_context[user_id] = message.text
            bot.send_message(user_id, "Введіть ваше повідомлення:")
            bot.register_next_step_handler(message, forward_message_to_admin)

        # Функція для пересилання повідомлення адміну
        def forward_message_to_admin(message):
            user_id = message.chat.id
            if user_id in user_context:
                for admin_id in ADMIN_USER_IDS:
                    bot.send_message(admin_id, f'Повідомлення від користувача {user_id}:\n\n{message.text}')
                bot.send_message(user_id, 'Ваше повідомлення надіслано адміну, очікуйте відповіді!')
                del user_context[user_id]
            else:
                bot.send_message(user_id, "Спочатку натисніть кнопку 'Написати адміну'.")

             
        

        def handle_inline_callbacks(call):
            chat_id = call.message.chat.id
            message_id = call.message.message_id

            if call.data.startswith("confirm_"):
                # Отримано запит на підтвердження від адміністратора
                user_id = int(call.data.split("_")[1])

                if user_id in user_balance_data:
                    # Зарахування грошей на рахунок користувача
                    balance = load_balance(user_id)
                    balance += user_balance_data[user_id]['amount']
                    save_balance(user_id, balance)

                    # Повідомлення користувачу про успішну операцію
                    success_message = f"Ваш баланс було поповнено на {user_balance_data[user_id]['amount']} грн. Операція успішно виконана!"
                    bot.send_message(user_id, success_message)

                    # Видалення повідомлення адміністратора і повідомлення про підтвердження
                    bot.delete_message(user_id, message_id)
                    bot.send_message(user_id, "Операцію підтверджено!")

                    # Видалення даних користувача з словника
                    del user_balance_data[user_id]
                else:
                    bot.send_message(chat_id, "Помилка: користувача не знайдено в базі даних.")

        # Обробник команди "Поповнити баланс"
        @bot.message_handler(func=lambda message: message.text == "Поповнити баланс")
        def handle_top_up_balance(message):
            chat_id = message.chat.id

            user_balance_data[chat_id] = {}  # Створюємо запис для поточного користувача
            user_balance_data[chat_id]['step'] = 1  # Встановлюємо етап на 1 (запит суми поповнення)
            user_balance_data[chat_id]['attempts'] = 3  # Ініціалізуємо спроби для користувача

            # Встановлюємо початкові реквізити
            user_balance_data[chat_id]['details'] = "4149 4991 4773 2411 1"

            bot.send_message(chat_id, "Скільки грошей ви бажаєте поповнити?")

        # Обробник всіх текстових повідомлень
        @bot.message_handler(func=lambda message: True)
        def handle_messages(message):
            chat_id = message.chat.id

            if chat_id in user_balance_data and 'step' in user_balance_data[chat_id]:
                if user_balance_data[chat_id]['step'] == 1:
                    if user_balance_data[chat_id]['attempts'] > 0:
                        try:
                            amount = float(message.text)
                            user_balance_data[chat_id]['amount'] = amount
                            user_balance_data[chat_id]['step'] = 2  # Переходимо на наступний етап (запит реквізитів)
                            bot.send_message(chat_id, "Будь ласка, введіть реквізити на які нарахуються гроші у разі виграшу. Для того щоб отримати внутрішньоігрову валюту закиньте гроші за реквізитом: 4441 1111 3329 3112")
                        except ValueError:
                            user_balance_data[chat_id]['attempts'] -= 1
                            bot.send_message(chat_id, f"Будь ласка, введіть коректну суму. Залишилось спроб: {user_balance_data[chat_id]['attempts']}")
                    else:
                        bot.send_message(chat_id, "Ви вичерпали всі спроби. Операція поповнення балансу термінується.")
                        del user_balance_data[chat_id]  # Видалення даних користувача

                elif user_balance_data[chat_id]['step'] == 2:
                    user_balance_data[chat_id]['details'] = message.text
                    user_balance_data[chat_id]['step'] = 3  # Переходимо на наступний етап (відправка запиту адміністраторам)

                    # Генеруємо номер чеку
                    receipt_number = ''.join(random.choices(string.digits, k=6))
                    current_time = time.strftime('%Y-%m-%d %H:%M:%S')

                    # Відправка запиту адміністраторам з інлайн-кнопкою "Підтвердити"
                    inline_keyboard = telebot.types.InlineKeyboardMarkup()
                    confirm_button = telebot.types.InlineKeyboardButton("Підтвердити", callback_data=f"confirm_{chat_id}")
                    inline_keyboard.add(confirm_button)

                    # Повідомлення для адміністраторів
                    for admin_id in ADMIN_USER_IDS:
                        admin_message = f"Користувач {chat_id} бажає поповнити баланс на суму {user_balance_data[chat_id]['amount']} грн. Реквізити: {user_balance_data[chat_id]['details']}\n"
                        admin_message += f"Час: {current_time}\nНомер чеку: {receipt_number}"

                        bot.send_message(admin_id, admin_message, reply_markup=inline_keyboard)

                    bot.send_message(chat_id, "Запит на поповнення балансу було надіслано адміністраторам. Будь ласка, зачекайте на підтвердження.")

        # Інші функції вашого бота

        # Обробник інлайн-запитів
        @bot.callback_query_handler(func=lambda call: True)
        def handle_inline_queries(call):
            handle_inline_callbacks(call)

if __name__ == '__main__':
    bot.polling(none_stop=True)


if __name__ == '__main__':
    bot.polling(none_stop=True)
